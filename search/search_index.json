{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto de Diego y Pedro","text":""},{"location":"#diego-barriga-gomez","title":"Diego Barriga G\u00f3mez","text":"<p>Me llamo Diego y soy un estudiante de ingenier\u00eda mecatr\u00f3nica de primer semestre, actualmente tengo 18 a\u00f1os y nac\u00ed en puebla donde he vivido toda mi vida, me gustan los deportes y pasar tiempo con mis amigos.</p> <p></p>"},{"location":"#logros-destacables","title":"Logros Destacables","text":"<p>Algunos de los logros que he tenido han sido realizar una tesina destacada sobre el consumo de alcohol en la com\u00fanidad y sus problemas, ser merecedor de una beca por nivel acad\u00e9mico para ingresasr a la IBERO Puebla.</p>"},{"location":"#contacto","title":"Contacto","text":"<p>Correo: 204334@iberopuebla.mx N\u00famero Celular: 2211338061</p>"},{"location":"#pedro-emmanuel-garcia-elvira","title":"Pedro Emmanuel Garcia Elvira","text":"<p>Soy pedro, actualmente estudiante de ingenier\u00eda mecatr\u00f3nica, soy de Veracruz, viv\u00ed muchos a\u00f1os en mexico y posteriormente en acapulco, tengo 17 a\u00f1os, me gusta cocinar, dibujar y leer.</p> <p></p>"},{"location":"#logros-importantes","title":"Logros importantes.","text":"<p>Clasifique como apto en el examen de conocimientos para la Escuela Naval y despu\u00e9s participe en la fase definitiva 2025, la cual tambi\u00e9n clasifique como apto, pero rechace la oferta academica.</p> <p>Jefe de grupo por un a\u00f1o completo en mi anterior escuela.</p>"},{"location":"#contacto_1","title":"Contacto","text":"<p>Correo: pedroemmanuel.garcia@iberopuebla.mx Chat: 205389@iberopuebla.mx</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Documentaci\u00f3n, Practicas","text":""},{"location":"comandos/#nombre-de-la-practica-funcionamiento-y-uso-de-la-compuerta-74ls555","title":"Nombre de la practica: Funcionamiento y uso de la compuerta 74ls555","text":"<p>Autores</p>"},{"location":"comandos/#garcia-elvira-pedro-emmanuel","title":"Garcia Elvira Pedro Emmanuel","text":""},{"location":"comandos/#barriga-gomez-diego","title":"Barriga G\u00f3mez Diego","text":""},{"location":"comandos/#fecha-5-de-septiembre-del-2025","title":"Fecha: 5 de Septiembre del 2025","text":"<p>Asignatura: Introducci\u00f3n a la Mecatronica</p>"},{"location":"comandos/#practica-con-el-temporizador-555","title":"Pr\u00e1ctica con el Temporizador 555","text":""},{"location":"comandos/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta pr\u00e1ctica de la materia \"Introducci\u00f3n a la Mecatr\u00f3nica\", se trabaj\u00f3 con el integrado 555, un componente que permite activar o desactivar funciones dentro de un circuito durante un tiempo determinado. Este intervalo puede modificarse ajustando los valores de las resistencias y capacitores empleados en el dise\u00f1o.</p>"},{"location":"comandos/#objetivo-de-la-practica","title":"Objetivo de la pr\u00e1ctica","text":"<p>El prop\u00f3sito fue lograr que un LED se encendiera durante un periodo de 3 a 5 segundos y permaneciera apagado durante el mismo intervalo de tiempo. De esta forma, se busc\u00f3 comprender c\u00f3mo el 555 puede controlar la frecuencia de parpadeo en funci\u00f3n de los componentes conectados.</p>"},{"location":"comandos/#uso-de-capacitores","title":"Uso de capacitores","text":"<p>Durante la clase se enfatiz\u00f3 en el uso de los capacitores, ya que el tema principal era analizar sus funciones y aplicaciones dentro de un circuito temporizador. Los capacitores se utilizaron para almacenar y liberar energ\u00eda, permitiendo modificar los tiempos de encendido y apagado del LED.</p>"},{"location":"comandos/#calculos-de-resistencia","title":"C\u00e1lculos de resistencia","text":"<p>Se nos proporcion\u00f3 una calculadora de componentes, la cual permit\u00eda ingresar los valores de dos resistencias y un capacitor. Una de las resistencias controlaba el tiempo de encendido, mientras que la otra regulaba el tiempo de apagado del LED.</p> <p>Adem\u00e1s, la calculadora mostraba el diagrama de conexi\u00f3n de los pines del 555 hacia la protoboard, lo que facilit\u00f3 seguir correctamente el esquema del circuito.</p>"},{"location":"comandos/#componentes-utilizados","title":"Componentes utilizados","text":"<p>En el caso de nuestro equipo, seleccionamos los siguientes valores:</p> <ul> <li>Resistencia 1: 1 k\u03a9  </li> <li>Resistencia 2: 20 k\u03a9  </li> <li>Capacitor: 330 \u00b5F  </li> </ul> <p>Estos componentes permitieron obtener el comportamiento deseado del circuito, con un parpadeo del LED dentro del rango de 3 a 5 segundos para cada ciclo.</p>"},{"location":"comandos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Gracias a esta pr\u00e1ctica comprendimos mejor c\u00f3mo las resistencias y los capacitores influyen en el tiempo de respuesta de un circuito con el temporizador 555. Adem\u00e1s, reforzamos la habilidad para interpretar y armar circuitos basados en diagramas electr\u00f3nicos.</p> <p></p> <p></p> <p></p> <p></p> <p>Pagina (https://www.digikey.com.mx/es/resources/conversion-calculators/conversion-calculator-555-timer?srsltid=AfmBOopExlAJ0hL2w6AKdoyEliUHPJePR_9zs5x8V6Y6rbOffRCSPgXM)</p>"},{"location":"comandos/#nombre-de-la-practica-funcionamiento-y-uso-del-microcontrolador-esp32","title":"Nombre de la practica: Funcionamiento y uso del microcontrolador ESP32","text":"<p>Autores</p>"},{"location":"comandos/#garcia-elvira-pedro-emmanuel_1","title":"Garcia Elvira Pedro Emmanuel","text":""},{"location":"comandos/#barriga-gomez-diego_1","title":"Barriga G\u00f3mez Diego","text":""},{"location":"comandos/#fecha-12-de-septiembre-del-2025","title":"Fecha: 12 de Septiembre del 2025","text":""},{"location":"comandos/#descripcion","title":"Descripci\u00f3n","text":"<p>En esta pr\u00e1ctica se trabaj\u00f3 con diversos componentes electr\u00f3nicos \u2014entre ellos el ESP32, jumpers y una protoboard\u2014 con el objetivo de implementar un circuito capaz de encender y apagar un diodo LED mediante la programaci\u00f3n del microcontrolador ESP32 desde un entorno computacional.</p>"},{"location":"comandos/#objetivos","title":"Objetivos","text":""},{"location":"comandos/#general","title":"General","text":"<p>En esta segunda practica de la asignatura \"Introducci\u00f3n a la Mecatr\u00f3nica\", se busc\u00f3 dise\u00f1ar e implementar un circuito controlado por un ESP32, programado para activar y desactivar un LED de acuerdo con las instrucciones definidas en el c\u00f3digo desarrollado durante la sesi\u00f3n.</p>"},{"location":"comandos/#especificos","title":"Espec\u00edficos","text":"<ul> <li>Objetivo 1: Superar el desempe\u00f1o obtenido en la primera practica, consolidando los conocimientos adquiridos y aplic\u00e1ndolos de manera m\u00e1s eficiente.  </li> <li>Objetivo 2: Profundizar en la comprensi\u00f3n del funcionamiento del ESP32, as\u00ed como en la l\u00f3gica de control digital mediante programaci\u00f3n estructurada.  </li> <li>Objetivo 3: Fortalecer las habilidades en el ensamblaje de circuitos electr\u00f3nicos y la implementaci\u00f3n de retardos temporales (delay) dentro de un programa.</li> </ul>"},{"location":"comandos/#alcance-y-exclusiones","title":"Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Los c\u00f3digos fuente empleados para la ejecuci\u00f3n de cada circuito.  </li> <li>Evidencias fotogr\u00e1ficas de las conexiones realizadas en la protoboard.  </li> </ul>"},{"location":"comandos/#procedimiento-1","title":"Procedimiento 1","text":"<ol> <li>Revisi\u00f3n de materiales: Se verific\u00f3 la disponibilidad y correcto funcionamiento de los componentes electr\u00f3nicos requeridos para la pr\u00e1ctica.  </li> <li>Configuraci\u00f3n inicial: Se realiz\u00f3 una breve introducci\u00f3n al uso del microcontrolador ESP32, abordando su conexi\u00f3n con la computadora y su programaci\u00f3n mediante un entorno de desarrollo compatible.  </li> <li>Dise\u00f1o del circuito: Se implement\u00f3 un circuito b\u00e1sico en la protoboard, conectando un LED a uno de los pines digitales de salida del ESP32, junto con la resistencia correspondiente para limitar la corriente.  </li> <li>Programaci\u00f3n: Se desarroll\u00f3 un script en lenguaje C/C++, el cual controla el encendido y apagado del LED utilizando la funci\u00f3n <code>delay()</code> para generar intervalos de tiempo visibles entre ambos estados.  </li> <li>Ejecuci\u00f3n y verificaci\u00f3n: Finalmente, se carg\u00f3 el programa al ESP32 y se comprob\u00f3 su correcto funcionamiento, verificando que el LED alternara su estado de encendido y apagado de acuerdo con el c\u00f3digo implementado.</li> </ol>"},{"location":"comandos/#codigo","title":"Codigo","text":""},{"location":"comandos/#const-int-led-33-puerto-del-esp32-al-que-esta-conectado-el-led-void-setup-serialbegin115200-pinmodeled-output-void-loop-repeticion-constante-del-encendido-y-apagado-digitalwriteled-1-encendido-delay1000-retraso-del-encendido-y-apagado-del-led-digitalwriteled-0-apagado-delay1000","title":"<pre><code>const int led = 33; // Puerto del ESP32 al que est\u00e1 conectado el LED\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {  // Repetici\u00f3n constante del encendido y apagado\n  digitalWrite(led, 1); // Encendido\n  delay(1000);          // Retraso del encendido y apagado del LED\n  digitalWrite(led, 0); // Apagado\n  delay(1000);\n}\n</code></pre>","text":""},{"location":"comandos/#procedimiento-2","title":"Procedimiento 2","text":"<p>Partiendo del c\u00f3digo y circuito desarrollados en la primera pr\u00e1ctica, se realizaron modificaciones tanto en el hardware como en el software.  </p> <p>En esta ocasi\u00f3n, se a\u00f1adi\u00f3 un bot\u00f3n pulsador al circuito con el prop\u00f3sito de controlar manualmente el encendido y apagado del LED al presionarlo. El bot\u00f3n se conect\u00f3 al pin 34 del ESP32, configurado como entrada digital.  </p> <p>Para implementar esta nueva funcionalidad, se declar\u00f3 una nueva constante en el c\u00f3digo correspondiente al pin del bot\u00f3n, y se agregaron estructuras condicionales que permiten determinar el estado del LED en funci\u00f3n de la lectura del pulsador: - Cuando el bot\u00f3n es presionado, el LED se enciende. - Cuando el bot\u00f3n no est\u00e1 presionado, el LED permanece apagado.  </p> <p>Estas modificaciones permitieron ampliar el control del sistema, pasando de un funcionamiento autom\u00e1tico a uno interactivo, donde la acci\u00f3n del usuario influye directamente en el comportamiento del circuito.</p> <pre><code>const int led=33; // LED\n\nconst int btn=34; // BOTON\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  pinMode(led, OUTPUT); // SALIDA\n\n  pinMode(btn, INPUT); // ENTRADA\n\n\n}\n\nvoid loop() {\n\n  int estado = digitalRead(btn); \n\n  if(estado == 1){\n\n     digitalWrite(led,1);  // PRENDIDO\n  }\n\n  else {\n\n    digitalWrite(led,0); // APAGADO\n\n  }\n\n}\n</code></pre>"},{"location":"comandos/#procedimiento-3","title":"Procedimiento 3","text":"<p>Para este tercer ejercicio se utiliz\u00f3 la aplicaci\u00f3n \"Serial Bluetooth Terminal\", la cual permite comunicarse con el ESP32 v\u00eda Bluetooth. Mediante la terminal de la aplicaci\u00f3n, se pueden enviar se\u00f1ales al microcontrolador para controlar el encendido y apagado del LED de acuerdo con el c\u00f3digo programado.  </p> <p>Partiendo del c\u00f3digo desarrollado en el Procedimiento 2, se realizaron las siguientes modificaciones:  </p> <ol> <li>Se a\u00f1adi\u00f3 la librer\u00eda <code>#include \"BluetoothSerial.h\"</code> para habilitar la comunicaci\u00f3n Bluetooth en el ESP32.  </li> <li>Se elimin\u00f3 la constante y configuraci\u00f3n del bot\u00f3n f\u00edsico, reemplazando la entrada por la conexi\u00f3n Bluetooth, que se denomin\u00f3 LR23 en el c\u00f3digo.  </li> <li>Las estructuras condicionales fueron adaptadas para funcionar con la aplicaci\u00f3n:  </li> <li>Si la terminal env\u00eda el mensaje <code>\"Prende\"</code>, el LED se enciende.  </li> <li>Si se recibe cualquier otro mensaje, el LED permanece apagado o se apaga.  </li> </ol> <p>Estas modificaciones permitieron controlar el LED de manera remota mediante Bluetooth, demostrando c\u00f3mo integrar comunicaciones inal\u00e1mbricas con sistemas embebidos.</p> <pre><code>\"#\"include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\nconst int led=33;\n\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  SerialBT.begin(\"LR23\"); // Dipositivo bluetooth\n\n  pinMode(led, OUTPUT);\n\n}\n\nvoid loop() {\n\n  if(SerialBT.available()){\n\n    String mensaje = SerialBT.readString();\n\n    Serial.println(\"Recibido: \" + mensaje);\n\n    if(mensaje == \"Prende\"){\n\n     digitalWrite(led,1);\n\n    }\n\n    else {\n\n      digitalWrite(led,0);\n    }\n\n  }\n\n  delay(100);\n\n }\n</code></pre>"},{"location":"comandos/#conclusion_1","title":"Conclusi\u00f3n","text":"<p>La pr\u00e1ctica permiti\u00f3 fortalecer la comprensi\u00f3n sobre la interacci\u00f3n entre hardware y software en sistemas embebidos, aplicando distintos m\u00e9todos de control de un LED utilizando el ESP32.  </p> <p>En el Procedimiento 1, se desarroll\u00f3 un circuito b\u00e1sico con encendido y apagado autom\u00e1tico mediante retardos temporales, lo que reforz\u00f3 la comprensi\u00f3n del control temporal en programaci\u00f3n.  </p> <p>En el Procedimiento 2, se integr\u00f3 un bot\u00f3n f\u00edsico como entrada digital, permitiendo el control manual del LED mediante estructuras condicionales, lo que ampli\u00f3 la experiencia en interacci\u00f3n hardware-software y en la gesti\u00f3n de entradas digitales.  </p> <p>Finalmente, en el Procedimiento 3, se implement\u00f3 comunicaci\u00f3n inal\u00e1mbrica v\u00eda Bluetooth utilizando la librer\u00eda <code>BluetoothSerial.h</code>, logrando controlar el LED de manera remota desde una aplicaci\u00f3n m\u00f3vil, lo que permiti\u00f3 explorar la integraci\u00f3n de sistemas embebidos con comunicaciones inal\u00e1mbricas.  </p> <p>En conjunto, estas pr\u00e1cticas consolidaron conocimientos en configuraci\u00f3n del ESP32, control de salidas digitales, gesti\u00f3n de entradas y condicionales, as\u00ed como en la interfaz con dispositivos externos mediante Bluetooth.</p> <p></p>"},{"location":"comandos/#nombre-de-la-practica-uso-de-motor-pwm-con-microcontrolador-esp32","title":"Nombre de la practica: Uso de motor PWM con microcontrolador ESP32","text":"<p>Autores</p>"},{"location":"comandos/#garcia-elvira-pedro-emmanuel_2","title":"Garcia Elvira Pedro Emmanuel","text":""},{"location":"comandos/#barriga-gomez-diego_2","title":"Barriga G\u00f3mez Diego","text":""},{"location":"comandos/#fecha-19-de-septiembre-del-2025","title":"Fecha: 19 de Septiembre del 2025","text":""},{"location":"comandos/#descripcion_1","title":"Descripci\u00f3n","text":"<p>En esta tercer practica de la materia Introducci\u00f3n a la Mecatr\u00f3nica, nuestro objetivo fue realizar la conexi\u00f3n y programaci\u00f3n de un motor DC para controlar su encendido, apagado y velocidad utilizando un ESP32. Se emplearon los pines digitales y la funci\u00f3n <code>ledcWrite()</code> para variar la velocidad del motor mediante la t\u00e9cnica de modulaci\u00f3n por ancho de pulso (PWM).</p>"},{"location":"comandos/#objetivos_1","title":"Objetivos","text":""},{"location":"comandos/#general_1","title":"General","text":"<p>Aprender a controlar un motor DC utilizando un microcontrolador, comprendiendo el funcionamiento de los pines de salida y el control de velocidad mediante PWM.</p>"},{"location":"comandos/#especificos_1","title":"Espec\u00edficos","text":"<ul> <li>Programar el encendido y cambio de giro del motor.  </li> <li>Implementar el control de velocidad utilizando la funci\u00f3n <code>ledcWrite()</code>.  </li> <li>Comprender la relaci\u00f3n entre frecuencia, ciclo de trabajo y velocidad del motor.</li> </ul>"},{"location":"comandos/#alcance-y-exclusiones_1","title":"Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Conexi\u00f3n del motor DC a trav\u00e9s del driver y pines de salida del ESP32.  </li> <li>C\u00f3digo para encendido, apagado y cambio de giro del motor.  </li> <li> <p>C\u00f3digo con control progresivo de velocidad mediante PWM.  </p> </li> <li> <p>No incluye: </p> </li> <li>Otros tipos de motores o controladores distintos al motor DC y driver utilizados.  </li> </ul>"},{"location":"comandos/#procedimiento","title":"Procedimiento","text":"<ol> <li>Se identificaron los pines de salida del microcontrolador y se realizaron las conexiones correspondientes del motor DC mediante el driver.  </li> <li>Una vez conectado, se desarroll\u00f3 un c\u00f3digo b\u00e1sico que permitiera:  </li> <li>Encender el motor en una direcci\u00f3n.  </li> <li>Detenerlo despu\u00e9s de un intervalo de 3 segundos.  </li> <li>Cambiar su giro en sentido contrario, manteniendo los mismos intervalos de tiempo.  </li> </ol>"},{"location":"comandos/#este-procedimiento-permitio-verificar-la-correcta-integracion-de-hardware-y-software-para-controlar-el-motor-dc-y-sentar-las-bases-para-implementar-control-de-velocidad-posteriormente","title":"Este procedimiento permiti\u00f3 verificar la correcta integraci\u00f3n de hardware y software para controlar el motor DC y sentar las bases para implementar control de velocidad posteriormente.","text":""},{"location":"comandos/#anexando-a-continuacion-el-primer-codigo-utilizado","title":"Anexando a continuaci\u00f3n el primer c\u00f3digo utilizado :","text":""},{"location":"comandos/#define-in1-32-define-in2-33-void-setup-pinmodein1-output-pinmodein2-output-void-loop-digitalwritein11-digitalwritein20-delay3000-digitalwritein10-digitalwritein20-delay3000-digitalwritein10-digitalwritein21-delay3000","title":"<pre><code>#define in1 32\n#define in2 33\n\nvoid setup() {\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(in1,1);\n  digitalWrite(in2,0);\n  delay(3000);\n  digitalWrite(in1,0);\n  digitalWrite(in2,0);\n  delay(3000);\n  digitalWrite(in1,0);\n  digitalWrite(in2,1);\n  delay(3000);\n}\n</code></pre>","text":""},{"location":"comandos/#control-progresivo-de-velocidad-del-motor","title":"Control Progresivo de Velocidad del Motor","text":"<p>Como segunda parte de este proyecto, y tomando como base lo realizado previamente, se program\u00f3 el motor DC de manera que fuera posible controlar su velocidad de forma gradual. El objetivo fue que el motor aumentara y disminuyera progresivamente su velocidad, en lugar de detenerse o arrancar de manera abrupta.  </p> <p>Esto es importante porque, aplicado a un motor real, un arranque o paro repentino podr\u00eda generar p\u00e9rdida de control o incluso un desgaste innecesario en el mecanismo.</p> <p>A continuaci\u00f3n, se presenta el segundo c\u00f3digo utilizado para implementar esta funcionalidad en el proyecto:</p> <pre><code>pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  //Control de velocidad\n  ledcAttachChannel(pwm,1000,8,0); //pin,frecuencia,bits,canal   //config\n\n}\n\nvoid loop() {\n  for(vel=0; vel&lt;=256;vel++){\n  ledcWrite(pwm,vel);\n  digitalWrite(in1,1);\n  digitalWrite(in2,0);\n  delay(10);\n  }\n  for(vel=256;vel&gt;=0;vel--){\n  digitalWrite(in1,1);\n  digitalWrite(in2,0);\n  delay(10);\n  }\n}\n</code></pre>"},{"location":"comandos/#conclusion_2","title":"Conclusi\u00f3n","text":"<p>La practica 3 permiti\u00f3 profundizar en el control de motores DC mediante un ESP32, combinando tanto la parte de encendido/apagado y cambio de giro, como el control progresivo de velocidad.  </p> <p>En la primera fase, se logr\u00f3 comprender la relaci\u00f3n entre los pines digitales, la l\u00f3gica de control y la implementaci\u00f3n de intervalos temporales para encender y apagar el motor de manera controlada.  </p> <p>En la segunda fase, se incorpor\u00f3 el control gradual de velocidad mediante la t\u00e9cnica de modulaci\u00f3n por ancho de pulso (PWM) utilizando la funci\u00f3n <code>ledcWrite()</code>. Esto permiti\u00f3 evitar arranques y paros bruscos, lo cual es fundamental para proteger el motor y el mecanismo acoplado, adem\u00e1s de ofrecer un comportamiento m\u00e1s realista y seguro del sistema.  </p> <p>En conjunto, el proyecto consolid\u00f3 conocimientos sobre: - Programaci\u00f3n de microcontroladores para control de actuadores. - Uso de PWM para control de velocidad de motores. - Integraci\u00f3n de hardware y software para aplicaciones de mecatr\u00f3nica. - Importancia de implementar estrategias de control progresivo para proteger los componentes y mejorar la eficiencia del sistema.</p>"},{"location":"ejemplo/","title":"Documentaci\u00f3n del Proyecto Final","text":""},{"location":"ejemplo/#ball-and-plate-system","title":"&gt; Ball and Plate System","text":""},{"location":"ejemplo/#1-introduccion","title":"1) Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Ball and Plate System </li> <li>Equipo / Autor(es): Alejandro Cordero G\u00f3nzalez, Jos\u00e9 Manuel G\u00f3ngora Compe\u00e1n, Diego Barriga G\u00f3mez, Pedro Emmanuel Garc\u00eda Elvira, Santiago Herrera Conde </li> <li>Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica </li> <li>Fecha: 05/12/2025 </li> <li>Descripci\u00f3n breve: Construir una plataforma que logre mantener en equilibrio una pelota</li> </ul>"},{"location":"ejemplo/#2-materiales","title":"2) Materiales","text":"<p>Materiales - PLA para impresi\u00f3n 3D, ESP32, Jumpers, Pilas de 3.7V, Portapilas, Servomotores</p>"},{"location":"ejemplo/#3-procedimiento","title":"3) Procedimiento","text":"<p>Dise\u00f1o - El prototipo fue dise\u00f1ado bas\u00e1ndose en im\u00e1genes de proyectos similares en internet para entender el funcionamiento de la mec\u00e1nica. - _Despu\u00e9s se comenz\u00f3 el dise\u00f1o para imprimirse algunas piezas en 3D mientras que algunas bases y soportes se hicieron en corte laser con mdf - Se imprimi\u00f3 lo que se deb\u00eda imprimir en 3D y tambi\u00e9n se cort\u00f3 en laser y aunque hubo problemas con las medidas se volvi\u00f3 a imprimir y cortar para lograr el soporte que se buscaba</p>"},{"location":"ejemplo/#4-programacion","title":"4) Programaci\u00f3n","text":"<p>Python -_import cv2 import numpy as np import bluetooth import time</p>"},{"location":"ejemplo/#function-to-connect-to-esp32","title":"FUNCTION TO CONNECT TO ESP32","text":"<p>port = 1 sock = bluetooth.BluetoothSocket()  # Use the default constructor (no arguments) sock.settimeout(20) video = cv2.VideoCapture(0)</p> <p>W= 640 H= 480</p> <p>print(\"Attempting to connect to ESP32...\") while True:     try:         sock.connect((\"68:25:DD:2E:E0:82\", port))         print(\"Connected to ESP32!\")         break     except Exception as e:         print(\"Error in connection... retrying:\", e) while True:</p> <p>ok,frame = video.read()</p> <p>if not ok:         break</p> <p>imagen = frame.copy()      hsv=cv2.cvtColor(imagen,cv2.COLOR_BGR2HSV)     bajo= np.array([0,50,50], dtype=np.uint8)     alto= np.array([10,255,255], dtype=np.uint8)     mask = cv2.inRange(hsv, bajo, alto)</p> <p>result=cv2.bitwise_and(imagen,imagen, mask=mask)     lista_contornos, jerarquia = cv2.findContours(mask , cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</p> <p>area_grande = 0      for contorno_n in lista_contornos:         area = cv2.contourArea(contorno_n)         if area &gt; area_grande:             area_grande=area</p> <p>contorno_final = contorno_n         else:</p> <p>continue</p> <p>(x,y), radio= cv2.minEnclosingCircle(contorno_final)</p> <p>cv2.circle(frame,(int(x),int(y)), int(radio),(255,0,0),3)  cv2.circle(frame,(int(x),int(y)), 3,(255,0,0),3)</p> <p>w=frame.shape[1]     h=frame.shape[0]</p> <p>Errorx=int(x-(w/2))     Errory=int(y-(h/2))     mensaje=str(Errorx)+','+str(Errory)+'\\n'     print(\"Sent:\",mensaje)     mensaje=str(Errorx)+','+str(Errory)+'\\n'     try:         sock.send(mensaje.encode())         print(\"Sent:\",mensaje)     except Exception as e:         print(\"Error sending data:\", e)      cv2.imshow(\"camara\",frame)     if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break</p> <p>video.release()_</p> <p>Este c\u00f3digo trabaja para el funcionamiento de la c\u00e1mara para que detecte en un punto la pelota y detecte el error en el \u00e1rea de visi\u00f3n de la c\u00e1mara.</p> <p>C\u00f3digo Arduino para ESP32</p> <p>float kp=0.8; float ki=0.01; float kd=0.8;</p>"},{"location":"ejemplo/#include-bluetoothserialh","title":"include \"BluetoothSerial.h\"","text":"<p>// Check if Bluetooth is available</p>"},{"location":"ejemplo/#if-definedconfig_bt_enabled-definedconfig_bluedroid_enabled","title":"if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)","text":""},{"location":"ejemplo/#error-bluetooth-is-not-enabled-please-run-make-menuconfig-to-and-enable-it","title":"error Bluetooth is not enabled! Please run <code>make menuconfig</code> to and enable it","text":""},{"location":"ejemplo/#endif","title":"endif","text":"<p>// Check Serial Port Profile</p>"},{"location":"ejemplo/#if-definedconfig_bt_spp_enabled","title":"if !defined(CONFIG_BT_SPP_ENABLED)","text":""},{"location":"ejemplo/#error-serial-port-profile-for-bluetooth-is-not-available-or-not-enabled-it-is-only-available-for-the-esp32-chip","title":"error Serial Port Profile for Bluetooth is not available or not enabled. It is only available for the ESP32 chip.","text":""},{"location":"ejemplo/#endif_1","title":"endif","text":""},{"location":"ejemplo/#define-servo_pin1-32","title":"define SERVO_PIN1 32","text":""},{"location":"ejemplo/#define-servo_pin2-33","title":"define SERVO_PIN2 33","text":"<p>float dtx=0; float t_nowx=0; float t_befx=0; int error_antx=0; float dty=0; float t_nowy=0; float t_befy=0; int error_anty=0;</p> <p>BluetoothSerial SerialBT;</p> <p>void setup() {   Serial.begin(115200);   SerialBT.begin(\"tommy11\");  //Bluetooth device name   //SerialBT.deleteAllBondedDevices(); // Uncomment this to delete paired devices; Must be called after begin   ledcAttach(SERVO_PIN1, 50, 8);   ledcAttach(SERVO_PIN2, 50, 8); }</p> <p>void loop() {   if (SerialBT.available()) {     String msj = SerialBT.readStringUntil('\\n');     Serial.println(msj);     //157,180     String EX_str = msj.substring(0,msj.indexOf(','));//Corta el mensaje de pos 0 y hasta la ,     int Ex_int = EX_str.toInt();     String EY_str = msj.substring(msj.indexOf(',')+1);//Corta el mensaje de pos 0 y hasta la ,     int Ey_int = EY_str.toInt();     t_nowx = millis();     dtx=t_nowx-t_befx;</p> <p>Ex_int= map(Ex_int, 0,90,-320,320);     float Px = kp *Ex_int;     double integralx = integralx + Ex_int * dtx;     float Ix = ki * integralx;     int derivadax= (Ex_int-error_antx)/dtx;     float Dx = kd * derivadax;     int posx = Px + Ix + Dx;     int error_antx=Ex_int;     t_befx=t_nowx;</p> <p>Serial.print(Ex_int);     int moverx= map(Ex_int, 0, 180, 205, 410);     ledcWrite(SERVO_PIN1, moverx);</p> <p>t_nowy = millis();     dty=t_nowy-t_befy;     Ey_int=map(Ey_int,0,90,-240,240);     //Convierte erro en pixel a erro en grados     float Py=kpEy_int;     double integraly= integraly + Ey_int dty;     float Iy =ki * integraly;     int derivaday=(Ey_int-error_anty)/dty;     float Dy = kd* derivaday;     int posy= Py+ Iy + Dy;     error_anty= Ey_int;     t_befy=t_nowy;</p> <p>int movery= map(Ey_int, 0, 180, 205, 410);     Serial.println(Ey_int);     Serial.println(movery);     ledcWrite(SERVO_PIN2,movery);</p> <p>}   //EX =  -W/2 -&gt; w/2 = -320 a 320   //EY =  -H/2 -&gt; H/2 = -240 a 240   delay(20); } Este c\u00f3digo decodifica las se\u00f1ales mandadas por la c\u00e1mara para transformarlas en movimientos de los Servomotores y lograr el movimiento que se desea</p>"},{"location":"ejemplo/#5-resultados","title":"5) Resultados","text":"<p>Resultado -Funcion\u00f3 parcialmente ya que a pesar de que el c\u00f3digo y el funcionamiento de los servomotores fue correcto, el motor no aguant\u00f3 completamente el peso de la base por lo que no se movia de manera satisfactoria por lo que la pelota al momento de moverla con cierta fuerza, la plataforma dejaba de lograr el movimiento completo y no la manten\u00eda en equilibrio. -A pesar de que tuvo esos errores, si el dise\u00f1o y distribuci\u00f3n de peso hubiera sido mejor controlado hubiera funcionado perfectamente.</p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}